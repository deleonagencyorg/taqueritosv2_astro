---
export interface GalleryImage {
  url: string;
  alt: string;
}

export interface ModalLabels {
  closeLabel: string;
  prevLabel: string;
  nextLabel: string;
}

export interface Props {
  images: GalleryImage[];
  modalLabels: ModalLabels;
  desktopColumns?: number;
  desktopRows?: number;
  mobileColumns?: number;
  mobileRows?: number;
  modalId?: string;
  className?: string;
  rotationInterval?: number;
}

const { 
  images = [],
  modalLabels,
  desktopColumns = 3, 
  desktopRows = 3, 
  mobileColumns = 2, 
  mobileRows = 2, 
  modalId = 'masonry-gallery-modal',
  className = '',
  rotationInterval = 4000
} = Astro.props;

// Validación de datos
const safeImages = Array.isArray(images) ? images : [];
const safeModalLabels = modalLabels || { 
  closeLabel: 'Close', 
  prevLabel: 'Previous', 
  nextLabel: 'Next' 
};

// Validación adicional para evitar errores
if (!safeImages || safeImages.length === 0) {
  console.warn('MasonryGallery: No images provided or images array is empty');
}

---

<div class={`masonry-gallery ${className}`}>
  <div 
    class="masonry-container" 
    style={`--desktop-columns: ${desktopColumns}; --desktop-rows: ${desktopRows}; --mobile-columns: ${mobileColumns}; --mobile-rows: ${mobileRows};`}
    data-total-images={safeImages.length}
    data-rotation-interval={rotationInterval}
  >
    {safeImages.slice(0, desktopColumns * desktopRows).map((image, index) => (
      <div 
        class="masonry-item" 
        data-index={index}
        data-original-index={index}
      >
        <img 
          src={image.url} 
          alt={image.alt}
          loading="lazy"
          class="masonry-image"
        />
        <div class="masonry-overlay">
          <div class="view-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M1 12C1 12 5 4 12 4C19 4 23 12 23 12C23 12 19 20 12 20C5 20 1 12 1 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <circle cx="12" cy="12" r="3" stroke="currentColor" stroke-width="2"/>
            </svg>
          </div>
        </div>
      </div>
    ))}
  </div>
</div>

<!-- Modal Slider -->
<div id={modalId} class="modal-overlay" style="display: none;">
  <div class="modal-content">
    <button class="modal-close" aria-label={safeModalLabels.closeLabel}>
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <line x1="18" y1="6" x2="6" y2="18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        <line x1="6" y1="6" x2="18" y2="18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
    </button>
    
    <button class="modal-prev" aria-label={safeModalLabels.prevLabel}>
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <polyline points="15,18 9,12 15,6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    
    <button class="modal-next" aria-label={safeModalLabels.nextLabel}>
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <polyline points="9,18 15,12 9,6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    
    <div class="modal-image-container">
      <img class="modal-image" src="" alt="" />
    </div>
    
    <div class="modal-counter">
      <span class="current-image">1</span> / <span class="total-images">{safeImages.length}</span>
    </div>
  </div>
</div>

<script define:vars={{ safeImages, safeModalLabels, desktopColumns, desktopRows, mobileColumns, mobileRows, modalId, rotationInterval }}>
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.querySelector('.masonry-container');
    const modal = document.getElementById(modalId);
    
    if (!container || !modal || !safeImages || safeImages.length === 0) {
      console.warn('MasonryGallery: Missing required elements or images');
      return;
    }
    
    const modalImage = modal.querySelector('.modal-image');
    const currentCounter = modal.querySelector('.current-image');
    const totalCounter = modal.querySelector('.total-images');
    const closeBtn = modal.querySelector('.modal-close');
    const prevBtn = modal.querySelector('.modal-prev');
    const nextBtn = modal.querySelector('.modal-next');
    
    let currentImageIndex = 0;
    let rotationTimer;
    let isRotating = false;
    
    // Configurar masonry y rotación
    function initializeMasonry() {
      const items = container.querySelectorAll('.masonry-item');
      const totalImages = safeImages.length;
      const visibleSlots = getVisibleSlots();
      
      // Configurar cada item inicial
      items.forEach((item, index) => {
        const img = item.querySelector('img');
        if (!img || !safeImages[index]) return;
        
        // Configurar imagen
        img.src = safeImages[index].url;
        img.alt = safeImages[index].alt;
        item.dataset.imageIndex = index.toString();
        
        // Aplicar aspect ratio y spans cuando la imagen cargue
        img.onload = () => applyMasonryLayout(item, img);
        img.onerror = () => {
          console.warn(`Failed to load image: ${img.src}`);
          item.style.display = 'none';
        };
        
        // Animación de entrada escalonada
        setTimeout(() => {
          item.classList.add('loaded');
        }, index * 150);
        
        // Event listener para modal
        item.addEventListener('click', () => {
          const imageIndex = parseInt(item.dataset.imageIndex);
          openModal(imageIndex);
        });
      });
      
      // Iniciar rotación si hay más imágenes disponibles
      if (totalImages > visibleSlots) {
        startRotation();
      }
    }
    
    function getVisibleSlots() {
      return window.innerWidth > 768 ? desktopColumns * desktopRows : mobileColumns * mobileRows;
    }
    
    function applyMasonryLayout(item, img) {
      const aspectRatio = img.naturalWidth / img.naturalHeight;
      const isMobile = window.innerWidth <= 768;
      
      // Aplicar spans basados en aspect ratio y dispositivo
      if (!isMobile && aspectRatio > 1.5) {
        // Imagen muy horizontal en desktop
        item.style.gridColumn = 'span 2';
        item.style.gridRow = 'span 1';
        item.dataset.masonryType = 'wide';
      } else if (!isMobile && aspectRatio < 0.7) {
        // Imagen muy vertical en desktop
        item.style.gridColumn = 'span 1';
        item.style.gridRow = 'span 2';
        item.dataset.masonryType = 'tall';
      } else {
        // Imagen normal o mobile
        item.style.gridColumn = 'span 1';
        item.style.gridRow = 'span 1';
        item.dataset.masonryType = 'normal';
      }
    }
    
    function startRotation() {
      if (isRotating) return;
      
      isRotating = true;
      const items = container.querySelectorAll('.masonry-item');
      const visibleSlots = items.length;
      const totalImages = safeImages.length;
      
      // Pool de imágenes disponibles para rotación
      let currentPool = Array.from({length: visibleSlots}, (_, i) => i);
      let availableImages = Array.from({length: totalImages}, (_, i) => i).slice(visibleSlots);
      
      rotationTimer = setInterval(() => {
        if (availableImages.length === 0) {
          // Reiniciar pool cuando se agoten las imágenes
          availableImages = Array.from({length: totalImages}, (_, i) => i);
          currentPool = [];
        }
        
        // Seleccionar slot y nueva imagen aleatoriamente
        const randomSlot = Math.floor(Math.random() * visibleSlots);
        const randomImageIndex = Math.floor(Math.random() * availableImages.length);
        const newImageIndex = availableImages[randomImageIndex];
        
        const targetItem = items[randomSlot];
        const targetImg = targetItem.querySelector('img');
        const newImage = safeImages[newImageIndex];
        
        if (!targetItem || !targetImg || !newImage) return;
        
        // Animación de salida
        targetItem.classList.add('rotating-out');
        
        setTimeout(() => {
          // Cambiar imagen
          targetImg.src = newImage.url;
          targetImg.alt = newImage.alt;
          targetItem.dataset.imageIndex = newImageIndex.toString();
          
          // Recalcular layout cuando la nueva imagen cargue
          targetImg.onload = () => {
            applyMasonryLayout(targetItem, targetImg);
            
            // Animación de entrada
            targetItem.classList.remove('rotating-out');
            targetItem.classList.add('rotating-in');
            
            setTimeout(() => {
              targetItem.classList.remove('rotating-in');
            }, 600);
          };
          
          // Actualizar pools
          if (currentPool[randomSlot] !== undefined) {
            availableImages.push(currentPool[randomSlot]);
          }
          currentPool[randomSlot] = newImageIndex;
          availableImages.splice(randomImageIndex, 1);
        }, 400);
        
      }, rotationInterval);
    }
    
    function stopRotation() {
      if (rotationTimer) {
        clearInterval(rotationTimer);
        rotationTimer = null;
        isRotating = false;
      }
    }
    
    // Modal functions
    function openModal(imageIndex) {
      if (imageIndex < 0 || imageIndex >= safeImages.length) return;
      
      currentImageIndex = imageIndex;
      updateModalImage();
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      
      // Pausar rotación mientras el modal está abierto
      stopRotation();
    }
    
    function closeModal() {
      modal.style.display = 'none';
      document.body.style.overflow = 'auto';
      
      // Reanudar rotación
      if (safeImages.length > getVisibleSlots()) {
        startRotation();
      }
    }
    
    function updateModalImage() {
      const image = safeImages[currentImageIndex];
      if (!image) return;
      
      modalImage.src = image.url;
      modalImage.alt = image.alt;
      currentCounter.textContent = currentImageIndex + 1;
      totalCounter.textContent = safeImages.length;
    }
    
    function nextImage() {
      currentImageIndex = (currentImageIndex + 1) % safeImages.length;
      updateModalImage();
    }
    
    function prevImage() {
      currentImageIndex = currentImageIndex === 0 ? safeImages.length - 1 : currentImageIndex - 1;
      updateModalImage();
    }
    
    // Event listeners
    closeBtn?.addEventListener('click', closeModal);
    nextBtn?.addEventListener('click', nextImage);
    prevBtn?.addEventListener('click', prevImage);
    
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });
    
    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (modal.style.display === 'flex') {
        switch(e.key) {
          case 'Escape':
            closeModal();
            break;
          case 'ArrowRight':
            nextImage();
            break;
          case 'ArrowLeft':
            prevImage();
            break;
        }
      }
    });
    
    // Responsive handling
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        stopRotation();
        
        // Reconfigurar layout para nuevo tamaño
        const items = container.querySelectorAll('.masonry-item');
        items.forEach(item => {
          const img = item.querySelector('img');
          if (img && img.complete) {
            applyMasonryLayout(item, img);
          }
        });
        
        // Reiniciar rotación si es necesario
        if (safeImages.length > getVisibleSlots()) {
          setTimeout(startRotation, 500);
        }
      }, 300);
    });
    
    // Pausar rotación cuando la pestaña no está visible
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stopRotation();
      } else if (safeImages.length > getVisibleSlots() && modal.style.display !== 'flex') {
        startRotation();
      }
    });
    
    // Initialize
    initializeMasonry();
  });
</script>

<style>
  .masonry-gallery {
    width: 100%;
    padding: 1rem;
    margin-bottom: 2rem;
  }
  
  .masonry-container {
    display: grid;
    grid-template-columns: repeat(var(--desktop-columns, 3), 1fr);
    grid-auto-rows: minmax(180px, auto);
    gap: 0.5rem;
    width: 100%;
    height: 800px;
    overflow: hidden;
    grid-auto-flow: dense;
    align-items: start;
  }
  
  .masonry-item {
    position: relative;
    overflow: hidden;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    opacity: 0;
    transform: translateY(40px) scale(0.9);
  }
  
  .masonry-item.loaded {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
  
  .masonry-item.rotating-out {
    opacity: 0;
    transform: scale(0.85) rotateY(90deg);
    transition: all 0.4s ease-in-out;
  }
  
  .masonry-item.rotating-in {
    opacity: 1;
    transform: scale(1) rotateY(0deg);
    transition: all 0.6s ease-out;
  }
  
  .masonry-item:hover {
    transform: translateY(-8px) scale(1.03);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
  }
  
  .masonry-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    transition: transform 0.6s ease;
    border-radius: 12px;
    display: block;
  }
  
  .masonry-item:hover .masonry-image {
    transform: scale(1.1);
  }
  
  .masonry-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.6) 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.3s ease;
    border-radius: 12px;
  }
  
  .masonry-item:hover .masonry-overlay {
    opacity: 1;
  }
  
  .view-icon {
    color: white;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    transform: scale(0.8);
    transition: transform 0.3s ease;
  }
  
  .masonry-item:hover .view-icon {
    transform: scale(1);
  }
  
  /* Modal Styles */
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
  }
  
  .modal-content {
    position: relative;
    max-width: 90vw;
    max-height: 90vh;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .modal-image-container {
    max-width: 100%;
    max-height: 100%;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  }
  
  .modal-image {
    max-width: 100%;
    max-height: 90vh;
    object-fit: contain;
    border-radius: 12px;
  }
  
  .modal-close, .modal-prev, .modal-next {
    position: absolute;
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: white;
    cursor: pointer;
    padding: 12px;
    border-radius: 50%;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .modal-close {
    top: 20px;
    right: 20px;
  }
  
  .modal-prev {
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
  }
  
  .modal-next {
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
  }
  
  .modal-close:hover, .modal-prev:hover, .modal-next:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: translateY(-50%) scale(1.1);
  }
  
  .modal-close:hover {
    transform: scale(1.1);
  }
  
  .modal-counter {
    position: absolute;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(10px);
    padding: 8px 20px;
    border-radius: 25px;
    font-weight: 500;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  /* Responsive Design */
  @media (max-width: 768px) {
    .masonry-container {
      grid-template-columns: repeat(var(--mobile-columns, 2), 1fr);
      grid-auto-rows: minmax(150px, auto);
      height: 500px;
      gap: 0.5rem;
    }
    
    .masonry-gallery {
      padding: 0.5rem;
      margin-bottom: 1.5rem;
    }
    
    .masonry-item {
      border-radius: 12px;
    }
    
    .modal-close, .modal-prev, .modal-next {
      padding: 10px;
    }
    
    .modal-counter {
      bottom: 20px;
      padding: 6px 16px;
      font-size: 14px;
    }
  }
  
  @media (max-width: 480px) {
    .masonry-container {
      height: 400px;
      grid-auto-rows: minmax(120px, auto);
    }
    
    .modal-close, .modal-prev, .modal-next {
      padding: 8px;
    }
  }
  
  /* Animaciones adicionales */
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }
  
  .masonry-item.rotating-out .masonry-image {
    animation: pulse 0.4s ease-in-out;
  }
  
  /* Mejoras de accesibilidad */
  @media (prefers-reduced-motion: reduce) {
    .masonry-item,
    .masonry-image,
    .masonry-overlay,
    .view-icon {
      transition: none;
    }
    
    .masonry-item.rotating-out,
    .masonry-item.rotating-in {
      transition: opacity 0.2s ease;
      transform: none;
    }
  }
</style>
